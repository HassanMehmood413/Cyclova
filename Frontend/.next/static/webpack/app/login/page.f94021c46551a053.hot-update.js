"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./app/context/AuthContext.tsx":
/*!*************************************!*\
  !*** ./app/context/AuthContext.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [token, setToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true); // Start with loading true\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Load auth state from localStorage on initial mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const initAuth = async ()=>{\n            try {\n                const storedToken = localStorage.getItem(\"token\");\n                const storedUser = localStorage.getItem(\"user\");\n                if (storedToken) {\n                    setToken(storedToken);\n                    if (storedUser) {\n                        // Try to parse stored user data\n                        try {\n                            const userData = JSON.parse(storedUser);\n                            setUser(userData);\n                        } catch (err) {\n                            console.error(\"Failed to parse stored user data:\", err);\n                            // If parsing fails, fetch fresh data\n                            await fetchUserData(storedToken);\n                        }\n                    } else {\n                        // No stored user, fetch from API\n                        await fetchUserData(storedToken);\n                    }\n                }\n            } catch (err) {\n                console.error(\"Error initializing auth:\", err);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        initAuth();\n    }, []);\n    const login = async (email, password)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            console.log(\"Attempting login with:\", email);\n            // Connect directly to the backend server\n            const response = await fetch(\"http://localhost:8000/login\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                },\n                body: new URLSearchParams({\n                    username: email,\n                    password\n                })\n            });\n            console.log(\"Login response status:\", response.status);\n            const responseText = await response.text();\n            console.log(\"Raw response:\", responseText.substring(0, 200)); // Log just the beginning to avoid clutter\n            // Try to parse the response as JSON\n            try {\n                const data = JSON.parse(responseText);\n                console.log(\"Login response data:\", data);\n                if (!data.access_token) {\n                    throw new Error(\"No access token found in response\");\n                }\n                const accessToken = data.access_token;\n                setToken(accessToken);\n                localStorage.setItem(\"token\", accessToken);\n                // Fetch user data with the token\n                const userData = await fetchUserData(accessToken);\n                if (userData) {\n                    // Store the user data in localStorage for persistence\n                    localStorage.setItem(\"user\", JSON.stringify(userData));\n                }\n                // Force a reload of the page to ensure all components reflect the logged in state\n                window.location.href = \"/\";\n            } catch (e) {\n                console.error(\"Failed to parse JSON response:\", e);\n                throw new Error(\"Invalid response format from server. Make sure your backend is running at http://localhost:8000\");\n            }\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"An error occurred\");\n            console.error(\"Login error:\", err);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const register = async (username, email, password)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const response = await fetch(\"/user\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    username,\n                    email,\n                    password\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({\n                        detail: \"Registration failed\"\n                    }));\n                throw new Error(errorData.detail || \"Registration failed\");\n            }\n            // Auto login after successful registration\n            await login(email, password);\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"An error occurred\");\n            console.error(\"Registration error:\", err);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const fetchUserData = async (authToken)=>{\n        try {\n            // First try to get the user ID from the JWT token\n            const tokenParts = authToken.split(\".\");\n            if (tokenParts.length === 3) {\n                // Parse the payload part of the JWT\n                const payload = JSON.parse(atob(tokenParts[1]));\n                const userId = payload.sub;\n                if (userId) {\n                    // Fetch the user data by ID - connect directly to backend\n                    const response = await fetch(\"http://localhost:8000/user/\".concat(userId), {\n                        headers: {\n                            \"Authorization\": \"Bearer \".concat(authToken)\n                        }\n                    });\n                    if (response.ok) {\n                        const userData = await response.json();\n                        setUser(userData);\n                        return userData;\n                    }\n                }\n            }\n            // Fallback: try to fetch user list and find our user - connect directly to backend\n            const fallbackResponse = await fetch(\"http://localhost:8000/user\", {\n                headers: {\n                    \"Authorization\": \"Bearer \".concat(authToken)\n                }\n            });\n            if (fallbackResponse.ok) {\n                const users = await fallbackResponse.json();\n                if (Array.isArray(users) && users.length > 0) {\n                    const userData = users[0]; // Just use the first user as fallback\n                    setUser(userData);\n                    return userData;\n                }\n            }\n            return null;\n        } catch (err) {\n            console.error(\"Error fetching user data:\", err);\n            return null;\n        }\n    };\n    const logout = ()=>{\n        setUser(null);\n        setToken(null);\n        localStorage.removeItem(\"token\");\n        localStorage.removeItem(\"user\");\n        window.location.href = \"/\";\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            user,\n            token,\n            login,\n            register,\n            logout,\n            isLoading,\n            error\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"D:\\\\AI\\\\Gen_AI_Projects\\\\Hackathons\\\\Cyclova\\\\Frontend\\\\app\\\\context\\\\AuthContext.tsx\",\n        lineNumber: 209,\n        columnNumber: 5\n    }, this);\n}\n_s(AuthProvider, \"mzZbxlz3rJTcku+Jn+vbpbhpSMU=\");\n_c = AuthProvider;\nfunction useAuth() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error(\"useAuth must be used within an AuthProvider\");\n    }\n    return context;\n}\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb250ZXh0L0F1dGhDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRWtGO0FBa0JsRixNQUFNSSw0QkFBY0osb0RBQWFBLENBQThCSztBQUV4RCxTQUFTQyxhQUFhLEtBQXFDO1FBQXJDLEVBQUVDLFFBQVEsRUFBMkIsR0FBckM7O0lBQzNCLE1BQU0sQ0FBQ0MsTUFBTUMsUUFBUSxHQUFHUCwrQ0FBUUEsQ0FBYztJQUM5QyxNQUFNLENBQUNRLE9BQU9DLFNBQVMsR0FBR1QsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU0sQ0FBQ1UsV0FBV0MsYUFBYSxHQUFHWCwrQ0FBUUEsQ0FBQyxPQUFPLDBCQUEwQjtJQUM1RSxNQUFNLENBQUNZLE9BQU9DLFNBQVMsR0FBR2IsK0NBQVFBLENBQWdCO0lBRWxELHFEQUFxRDtJQUNyREMsZ0RBQVNBLENBQUM7UUFDUixNQUFNYSxXQUFXO1lBQ2YsSUFBSTtnQkFDRixNQUFNQyxjQUFjQyxhQUFhQyxPQUFPLENBQUM7Z0JBQ3pDLE1BQU1DLGFBQWFGLGFBQWFDLE9BQU8sQ0FBQztnQkFFeEMsSUFBSUYsYUFBYTtvQkFDZk4sU0FBU007b0JBRVQsSUFBSUcsWUFBWTt3QkFDZCxnQ0FBZ0M7d0JBQ2hDLElBQUk7NEJBQ0YsTUFBTUMsV0FBV0MsS0FBS0MsS0FBSyxDQUFDSDs0QkFDNUJYLFFBQVFZO3dCQUNWLEVBQUUsT0FBT0csS0FBSzs0QkFDWkMsUUFBUVgsS0FBSyxDQUFDLHFDQUFxQ1U7NEJBQ25ELHFDQUFxQzs0QkFDckMsTUFBTUUsY0FBY1Q7d0JBQ3RCO29CQUNGLE9BQU87d0JBQ0wsaUNBQWlDO3dCQUNqQyxNQUFNUyxjQUFjVDtvQkFDdEI7Z0JBQ0Y7WUFDRixFQUFFLE9BQU9PLEtBQUs7Z0JBQ1pDLFFBQVFYLEtBQUssQ0FBQyw0QkFBNEJVO1lBQzVDLFNBQVU7Z0JBQ1JYLGFBQWE7WUFDZjtRQUNGO1FBRUFHO0lBQ0YsR0FBRyxFQUFFO0lBRUwsTUFBTVcs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RSxZQUFZdkUsV0FBVztRQUN6QixNQUFNLElBQUl1QyxNQUFNO0lBQ2xCO0lBQ0EsT0FBT2dDO0FBQ1Q7SUFOZ0JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9jb250ZXh0L0F1dGhDb250ZXh0LnRzeD85OWI3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmludGVyZmFjZSBVc2VyIHtcclxuICBpZDogbnVtYmVyO1xyXG4gIGVtYWlsOiBzdHJpbmc7XHJcbiAgdXNlcm5hbWU6IHN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIEF1dGhDb250ZXh0VHlwZSB7XHJcbiAgdXNlcjogVXNlciB8IG51bGw7XHJcbiAgdG9rZW46IHN0cmluZyB8IG51bGw7XHJcbiAgbG9naW46IChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHJlZ2lzdGVyOiAodXNlcm5hbWU6IHN0cmluZywgZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBsb2dvdXQ6ICgpID0+IHZvaWQ7XHJcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xyXG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xyXG59XHJcblxyXG5jb25zdCBBdXRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8QXV0aENvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEF1dGhQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XHJcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGU8VXNlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFt0b2tlbiwgc2V0VG9rZW5dID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpOyAvLyBTdGFydCB3aXRoIGxvYWRpbmcgdHJ1ZVxyXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIC8vIExvYWQgYXV0aCBzdGF0ZSBmcm9tIGxvY2FsU3RvcmFnZSBvbiBpbml0aWFsIG1vdW50XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGluaXRBdXRoID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlZFRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJyk7XHJcbiAgICAgICAgY29uc3Qgc3RvcmVkVXNlciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd1c2VyJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHN0b3JlZFRva2VuKSB7XHJcbiAgICAgICAgICBzZXRUb2tlbihzdG9yZWRUb2tlbik7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChzdG9yZWRVc2VyKSB7XHJcbiAgICAgICAgICAgIC8vIFRyeSB0byBwYXJzZSBzdG9yZWQgdXNlciBkYXRhXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdXNlckRhdGEgPSBKU09OLnBhcnNlKHN0b3JlZFVzZXIpO1xyXG4gICAgICAgICAgICAgIHNldFVzZXIodXNlckRhdGEpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugc3RvcmVkIHVzZXIgZGF0YTonLCBlcnIpO1xyXG4gICAgICAgICAgICAgIC8vIElmIHBhcnNpbmcgZmFpbHMsIGZldGNoIGZyZXNoIGRhdGFcclxuICAgICAgICAgICAgICBhd2FpdCBmZXRjaFVzZXJEYXRhKHN0b3JlZFRva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gc3RvcmVkIHVzZXIsIGZldGNoIGZyb20gQVBJXHJcbiAgICAgICAgICAgIGF3YWl0IGZldGNoVXNlckRhdGEoc3RvcmVkVG9rZW4pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGF1dGg6JywgZXJyKTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBpbml0QXV0aCgpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgY29uc3QgbG9naW4gPSBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xyXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG4gICAgc2V0RXJyb3IobnVsbCk7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyBsb2dpbiB3aXRoOicsIGVtYWlsKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENvbm5lY3QgZGlyZWN0bHkgdG8gdGhlIGJhY2tlbmQgc2VydmVyXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9sb2dpbicsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcclxuICAgICAgICAgIHVzZXJuYW1lOiBlbWFpbCwgLy8gQVBJIGV4cGVjdHMgJ3VzZXJuYW1lJyBhcyB0aGUgZmllbGQgbmFtZSBmb3IgZW1haWxcclxuICAgICAgICAgIHBhc3N3b3JkLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCdMb2dpbiByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgICBjb25zb2xlLmxvZygnUmF3IHJlc3BvbnNlOicsIHJlc3BvbnNlVGV4dC5zdWJzdHJpbmcoMCwgMjAwKSk7IC8vIExvZyBqdXN0IHRoZSBiZWdpbm5pbmcgdG8gYXZvaWQgY2x1dHRlclxyXG4gICAgICBcclxuICAgICAgLy8gVHJ5IHRvIHBhcnNlIHRoZSByZXNwb25zZSBhcyBKU09OXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KTtcclxuICAgICAgICBjb25zb2xlLmxvZygnTG9naW4gcmVzcG9uc2UgZGF0YTonLCBkYXRhKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIWRhdGEuYWNjZXNzX3Rva2VuKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiBmb3VuZCBpbiByZXNwb25zZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGRhdGEuYWNjZXNzX3Rva2VuO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHNldFRva2VuKGFjY2Vzc1Rva2VuKTtcclxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndG9rZW4nLCBhY2Nlc3NUb2tlbik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRmV0Y2ggdXNlciBkYXRhIHdpdGggdGhlIHRva2VuXHJcbiAgICAgICAgY29uc3QgdXNlckRhdGEgPSBhd2FpdCBmZXRjaFVzZXJEYXRhKGFjY2Vzc1Rva2VuKTtcclxuICAgICAgICBpZiAodXNlckRhdGEpIHtcclxuICAgICAgICAgIC8vIFN0b3JlIHRoZSB1c2VyIGRhdGEgaW4gbG9jYWxTdG9yYWdlIGZvciBwZXJzaXN0ZW5jZVxyXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3VzZXInLCBKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBGb3JjZSBhIHJlbG9hZCBvZiB0aGUgcGFnZSB0byBlbnN1cmUgYWxsIGNvbXBvbmVudHMgcmVmbGVjdCB0aGUgbG9nZ2VkIGluIHN0YXRlXHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnLyc7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZTonLCBlKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gc2VydmVyLiBNYWtlIHN1cmUgeW91ciBiYWNrZW5kIGlzIHJ1bm5pbmcgYXQgaHR0cDovL2xvY2FsaG9zdDo4MDAwJyk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0FuIGVycm9yIG9jY3VycmVkJyk7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvZ2luIGVycm9yOicsIGVycik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHJlZ2lzdGVyID0gYXN5bmMgKHVzZXJuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcclxuICAgIHNldElzTG9hZGluZyh0cnVlKTtcclxuICAgIHNldEVycm9yKG51bGwpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL3VzZXInLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIHVzZXJuYW1lLFxyXG4gICAgICAgICAgZW1haWwsXHJcbiAgICAgICAgICBwYXNzd29yZCxcclxuICAgICAgICB9KSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7IGRldGFpbDogJ1JlZ2lzdHJhdGlvbiBmYWlsZWQnIH0pKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmRldGFpbCB8fCAnUmVnaXN0cmF0aW9uIGZhaWxlZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBdXRvIGxvZ2luIGFmdGVyIHN1Y2Nlc3NmdWwgcmVnaXN0cmF0aW9uXHJcbiAgICAgIGF3YWl0IGxvZ2luKGVtYWlsLCBwYXNzd29yZCk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdBbiBlcnJvciBvY2N1cnJlZCcpO1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdSZWdpc3RyYXRpb24gZXJyb3I6JywgZXJyKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZmV0Y2hVc2VyRGF0YSA9IGFzeW5jIChhdXRoVG9rZW46IHN0cmluZyk6IFByb21pc2U8VXNlciB8IG51bGw+ID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEZpcnN0IHRyeSB0byBnZXQgdGhlIHVzZXIgSUQgZnJvbSB0aGUgSldUIHRva2VuXHJcbiAgICAgIGNvbnN0IHRva2VuUGFydHMgPSBhdXRoVG9rZW4uc3BsaXQoJy4nKTtcclxuICAgICAgaWYgKHRva2VuUGFydHMubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgLy8gUGFyc2UgdGhlIHBheWxvYWQgcGFydCBvZiB0aGUgSldUXHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoYXRvYih0b2tlblBhcnRzWzFdKSk7XHJcbiAgICAgICAgY29uc3QgdXNlcklkID0gcGF5bG9hZC5zdWI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHVzZXJJZCkge1xyXG4gICAgICAgICAgLy8gRmV0Y2ggdGhlIHVzZXIgZGF0YSBieSBJRCAtIGNvbm5lY3QgZGlyZWN0bHkgdG8gYmFja2VuZFxyXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cDovL2xvY2FsaG9zdDo4MDAwL3VzZXIvJHt1c2VySWR9YCwge1xyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YXV0aFRva2VufWAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9KTtcclxuICBcclxuICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgc2V0VXNlcih1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyRGF0YTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEZhbGxiYWNrOiB0cnkgdG8gZmV0Y2ggdXNlciBsaXN0IGFuZCBmaW5kIG91ciB1c2VyIC0gY29ubmVjdCBkaXJlY3RseSB0byBiYWNrZW5kXHJcbiAgICAgIGNvbnN0IGZhbGxiYWNrUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cDovL2xvY2FsaG9zdDo4MDAwL3VzZXInLCB7XHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YXV0aFRva2VufWAsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZmFsbGJhY2tSZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgZmFsbGJhY2tSZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXNlcnMpICYmIHVzZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IHVzZXJEYXRhID0gdXNlcnNbMF07IC8vIEp1c3QgdXNlIHRoZSBmaXJzdCB1c2VyIGFzIGZhbGxiYWNrXHJcbiAgICAgICAgICBzZXRVc2VyKHVzZXJEYXRhKTtcclxuICAgICAgICAgIHJldHVybiB1c2VyRGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHVzZXIgZGF0YTonLCBlcnIpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBsb2dvdXQgPSAoKSA9PiB7XHJcbiAgICBzZXRVc2VyKG51bGwpO1xyXG4gICAgc2V0VG9rZW4obnVsbCk7XHJcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndG9rZW4nKTtcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd1c2VyJyk7XHJcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcvJztcclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPEF1dGhDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7IHVzZXIsIHRva2VuLCBsb2dpbiwgcmVnaXN0ZXIsIGxvZ291dCwgaXNMb2FkaW5nLCBlcnJvciB9fT5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9BdXRoQ29udGV4dC5Qcm92aWRlcj5cclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXV0aCgpIHtcclxuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBdXRoQ29udGV4dCk7XHJcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VBdXRoIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gQXV0aFByb3ZpZGVyJyk7XHJcbiAgfVxyXG4gIHJldHVybiBjb250ZXh0O1xyXG59ICJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiQXV0aENvbnRleHQiLCJ1bmRlZmluZWQiLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJzZXRVc2VyIiwidG9rZW4iLCJzZXRUb2tlbiIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJpbml0QXV0aCIsInN0b3JlZFRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInN0b3JlZFVzZXIiLCJ1c2VyRGF0YSIsIkpTT04iLCJwYXJzZSIsImVyciIsImNvbnNvbGUiLCJmZXRjaFVzZXJEYXRhIiwibG9naW4iLCJlbWFpbCIsInBhc3N3b3JkIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiVVJMU2VhcmNoUGFyYW1zIiwidXNlcm5hbWUiLCJzdGF0dXMiLCJyZXNwb25zZVRleHQiLCJ0ZXh0Iiwic3Vic3RyaW5nIiwiZGF0YSIsImFjY2Vzc190b2tlbiIsIkVycm9yIiwiYWNjZXNzVG9rZW4iLCJzZXRJdGVtIiwic3RyaW5naWZ5Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiZSIsIm1lc3NhZ2UiLCJyZWdpc3RlciIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsImNhdGNoIiwiZGV0YWlsIiwiYXV0aFRva2VuIiwidG9rZW5QYXJ0cyIsInNwbGl0IiwibGVuZ3RoIiwicGF5bG9hZCIsImF0b2IiLCJ1c2VySWQiLCJzdWIiLCJmYWxsYmFja1Jlc3BvbnNlIiwidXNlcnMiLCJBcnJheSIsImlzQXJyYXkiLCJsb2dvdXQiLCJyZW1vdmVJdGVtIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUF1dGgiLCJjb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/context/AuthContext.tsx\n"));

/***/ })

});